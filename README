# PREPARING FOR TECHNICAL INTERVIEWS

Preparing for technical interviews requires moving away from memorizing "tricks" and moving toward a First Principles approach. Think of a LeetCode problem not as a coding puzzle, but as a transformation function where you must map an input state to an output state using the most efficient constraints.

############ Phase 1: The Formal Definition (The "What") ############

Before writing code, you must define the problem as a mathematical function. This prevents "coding by coincidence."
1. Define the Domain ($I$) and Codomain ($O$): What is the exact shape of the input and output? (e.g., Is the input a set, a sequence, or a directed graph?)
2. Identify Constraints ($C$): Look at the input size ($n$). This mathematically dictates your required time complexity:
    - $n \approx 10^2 -> O(n^3)$ (Nested loops)
    - $n \approx 10^3 -> O(n^2)$ (Quadratic/Nested loops)
    - $n \approx 10^5 -> O(n log n)$ or $O(n)$ (Sorting, Heaps, Two Pointers)
    - $n \approx 10^9 -> O(log n)$ or $O(1)$ (Binary Search, Math)
3. State the Invariant: What must remain true throughout the entire process? (e.g., "The window sum must always be less than or equal to k$").

############ Phase 2: The Logic Reduction (The "How") ############

Most problems boil down to a search or a transformation. Use this decision tree to find the "Mathematical Pattern":

1. Is it a Search in a Linear Space? 
If you are looking for an element or a range in a sequence:
    - Contiguous/Ordered? $\rightarrow$ Sliding Window or Two Pointers.
    - Sorted? $\rightarrow$ Binary Search.
    - Finding K-elements? $\rightarrow$ Heap (Priority Queue).

2. Is it a Search in a Non-Linear Space?
If the data points are connected by relationships:
    - Hierarchical? $\rightarrow$ Trees (Recursion/DFS).
    - Cyclic/Interconnected? $\rightarrow$ Graphs (BFS for shortest path, DFS for connectivity).

3. Is it an Optimization Problem?
If you see words like "Maximum," "Minimum," or "Shortest":
    - Can it be broken into sub-problems? $\rightarrow$ Dynamic Programming or Greedy?

############ Phase 3: The "Mathematical Formula" Tips ############

If you struggle to put formulas together, use the Induction Method. Don't try to solve for n; solve for 0, then 1, then n+1.
- The Base Case ($n=0$ or $n=1$): What is the simplest version of this problem?
- The Transition ($i \rightarrow i+1$): If I have the answer for the first $i$ elements, how does adding the $(i+1)^{th}$ element change it?
    - Example (Sliding Window): NewSum = OldSum + next_element - dropped_element.
- The Pointer Relation: In two-pointer problems, define the movement. Usually:
    - $$f(L, R) \rightarrow \text{move } R \text{ if condition } A, \text{ move } L \text{ if condition } B.$$

############ Phase 4: Drilling into Specific Types ############

Once you identify the "mathematical family," use these specific attack vectors:

Arrays & Strings (Linear Scans): Use a Prefix Sum or Frequency Map.

Sliding Window (Contiguous Ranges): Maintain a "window" that expands until a constraint is broken, then shrinks
- Formula: $Window = [left, right]$. Expand right to increase state; increment left to decrease state.

Two Pointers (Pairs/Sorting): Usually involves "squeezing" from both ends ($0$ and $n-1$) or "fast/slow" pointers to detect cycles.

Binary Search (Search Space Exhaustion): Itâ€™s not just for sorted arrays. It's for any monotonic function (where the answer is "No" for a while, then switches to "Yes" forever).
- Formula: $mid = left + \frac{right - left}{2}$.

Graphs & Trees (Connectivity): 
- BFS: Explores in "shells" (useful for shortest distance).
- DFS: Explores paths (useful for exhaustive search/backtracking).
- Complexity: Formula: $V + E$ (Vertices + Edges) complexity.

Dynamic Programming (Recurrence): Identify the State (what variables change?) and the Relation.
- Formula: $DP[i] = \max(DP[i-1], \text{current} + DP[i-2])$ (The classic "House Robber" recurrence).

############ Summary Checklist for your Interview ############:
1. Read: Identify the input/output and constraints.
2. Math: Write the recurrence relation or the invariant (e.g., $i < j$ and $A[i] < A[j]$).
3. Type: Is this a search, an optimization, or a traversal?
4. Dry Run: Test your logic with $n=1$ and $n=2$.
5. Code: Translate the math into logic.

